<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-title" content="L-sit Timer" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#111111" />
  <title>L-sit Timer (iPhone)</title>
  <style>
    :root{
      --bg:#0f0f0f; --panel:#161616; --border:#2a2a2a;
      --text:#ffffff; --muted:#bdbdbd;
      --accent:#4cff8f; --warn:#ffcc00; --danger:#ff4c4c;
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    body{
      margin:0; min-height:100vh;
      font-family: system-ui, -apple-system, "Segoe UI", Arial, sans-serif;
      background:var(--bg); color:var(--text);
      display:flex; align-items:center; justify-content:center;
    }
    .wrap{ width:min(860px, 94vw); padding:14px; }
    .panel{
      background:linear-gradient(180deg, #151515, #0f0f0f);
      border:1px solid var(--border);
      border-radius:18px;
      padding:16px;
      box-shadow: 0 14px 40px rgba(0,0,0,.45);
    }
    header{
      display:flex; justify-content:space-between; align-items:center; gap:12px;
      margin-bottom:10px;
    }
    h1{ margin:0; font-size:18px; font-weight:800; letter-spacing:.2px; }
    .chip{
      font-size:12px; color:#ddd;
      border:1px solid var(--border);
      border-radius:999px; padding:6px 10px;
      background:rgba(0,0,0,.25);
      white-space:nowrap;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(4, minmax(0,1fr));
      gap:10px;
      margin:10px 0 12px;
    }
    @media (max-width: 720px){
      .grid{ grid-template-columns: repeat(2, minmax(0,1fr)); }
    }
    label{
      display:grid; gap:6px;
      font-size:12px; color:#d6d6d6;
    }
    input{
      width:100%;
      padding:12px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:#0c0c0c; color:#fff;
      font-size:18px;
    }

    .stage{
      margin-top:6px;
      text-align:center;
      display:grid; gap:10px;
    }
    .badge{
      justify-self:center;
      font-size:14px;
      padding:8px 14px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.3);
    }
    .time{
      font-size: clamp(72px, 12vw, 120px);
      font-weight: 900;
      letter-spacing: 1px;
      line-height: 1;
      margin-top:2px;
    }
    .sub{
      color:var(--muted);
      font-size:15px;
      min-height: 20px;
    }

    .controls{
      display:flex; gap:10px; justify-content:center; flex-wrap:wrap;
      margin-top:10px;
    }
    button{
      border-radius:14px;
      border:1px solid var(--border);
      background:#0c0c0c;
      color:#fff;
      font-size:18px;
      padding:12px 18px;
      cursor:pointer;
      min-width: 120px;
    }
    button.primary{
      background: rgba(76,255,143,.12);
      border-color: rgba(76,255,143,.35);
    }
    button:disabled{ opacity:.45; cursor:not-allowed; }

    .opts{
      margin-top:10px;
      display:flex; gap:12px; justify-content:center; flex-wrap:wrap;
      align-items:center;
      color:#d6d6d6;
      font-size:13px;
    }
    .opts input[type="range"]{ width:160px; }
    .hint{
      margin-top:10px;
      text-align:center;
      color:#9a9a9a;
      font-size:12px;
      line-height:1.4;
    }

    /* Visual cues */
    .flash{
      position:fixed; inset:0;
      pointer-events:none;
      background:transparent;
      opacity:0;
      transition: opacity 120ms linear;
    }
    .flash.on{ opacity: .22; }
    .flash.warn{ background: var(--warn); }
    .flash.danger{ background: var(--danger); }
    .flash.accent{ background: var(--accent); }

    .accentText{ color: var(--accent); }
    .warnText{ color: var(--warn); }
    .dangerText{ color: var(--danger); }

    /* Prevent double-tap zoom on buttons (iOS often ok with meta viewport + large buttons) */
    button, input { touch-action: manipulation; }
  </style>
</head>

<body>
  <div class="flash" id="flash"></div>

  <div class="wrap">
    <div class="panel">
      <header>
        <h1>L-sit 循環計時器（iPhone 版）</h1>
        <div class="chip" id="stateChip">待機</div>
      </header>

      <div class="grid">
        <label>組數（4）
          <input id="sets" type="number" min="1" value="4" inputmode="numeric" />
        </label>
        <label>支撐秒（15–20）
          <input id="hold" type="number" min="1" value="20" inputmode="numeric" />
        </label>
        <label>休息秒（60–90）
          <input id="rest" type="number" min="0" value="60" inputmode="numeric" />
        </label>
        <label>準備秒（10）
          <input id="prep" type="number" min="0" value="10" inputmode="numeric" />
        </label>
      </div>

      <div class="stage">
        <div class="badge" id="badge">準備好後按「開始」</div>
        <div class="time" id="display">00:20</div>
        <div class="sub" id="sub">建議：把 iPhone 自動鎖定改成「永不」，訓練時不要鎖屏。</div>
      </div>

      <div class="controls">
        <button class="primary" id="start">開始</button>
        <button id="pause" disabled>暫停</button>
        <button id="reset">重置</button>
      </div>

      <div class="opts">
        <label style="display:flex; gap:8px; align-items:center;">
          <input id="mute" type="checkbox" />
          靜音
        </label>
        <span>音量</span>
        <input id="vol" type="range" min="0" max="100" value="60" />
      </div>

      <div class="hint">
        iPhone 上「震動」多數情況無效（iOS 限制），所以這版用「聲音 + 閃爍」作提示。<br>
        建議：Safari 開啟後 → 分享 →「加入主畫面」，使用體驗最像 App。
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const $sets = $("sets");
  const $hold = $("hold");
  const $rest = $("rest");
  const $prep = $("prep");

  const $stateChip = $("stateChip");
  const $badge = $("badge");
  const $display = $("display");
  const $sub = $("sub");

  const $start = $("start");
  const $pause = $("pause");
  const $reset = $("reset");

  const $mute = $("mute");
  const $vol = $("vol");
  const $flash = $("flash");

  // Settings
  let totalSets = 4, holdSec = 20, restSec = 60, prepSec = 10;

  // State
  let phase = "idle"; // idle | prep | hold | rest | done | paused
  let currentSet = 1;
  let remaining = 0;
  let timerId = null;

  // Audio (iOS needs user gesture to start AudioContext)
  let audioCtx = null;
  let audioUnlocked = false;

  function pad2(n){ return String(n).padStart(2, "0"); }
  function fmt(sec){
    const mm = Math.floor(sec / 60);
    const ss = sec % 60;
    return `${pad2(mm)}:${pad2(ss)}`;
  }

  function readInputs(){
    totalSets = Math.max(1, parseInt($sets.value || "4", 10));
    holdSec  = Math.max(1, parseInt($hold.value || "20", 10));
    restSec  = Math.max(0, parseInt($rest.value || "60", 10));
    prepSec  = Math.max(0, parseInt($prep.value || "10", 10));
  }

  function setControlsRunning(running){
    $start.disabled = running;
    $pause.disabled = !running;
    [$sets,$hold,$rest,$prep].forEach(el => el.disabled = running);
  }

  function setPhase(p){
    phase = p;
    if (phase === "prep") {
      $stateChip.textContent = "準備";
      $badge.textContent = "準備（就位）";
      $sub.textContent = "把手抓穩、肩下壓、核心先收緊。";
      $display.className = "time warnText";
    } else if (phase === "hold") {
      $stateChip.textContent = `撐｜第 ${currentSet}/${totalSets} 組`;
      $badge.textContent = `第 ${currentSet}/${totalSets} 組｜撐`;
      $sub.textContent = "保持穩定：不聳肩、不要晃、核心收緊。";
      $display.className = "time accentText";
    } else if (phase === "rest") {
      $stateChip.textContent = `休｜第 ${currentSet}/${totalSets} 組`;
      $badge.textContent = `第 ${currentSet}/${totalSets} 組｜休`;
      $sub.textContent = "休息調整呼吸，準備下一組。";
      $display.className = "time";
    } else if (phase === "done") {
      $stateChip.textContent = "完成";
      $badge.textContent = "完成 ✅";
      $sub.textContent = `本次 ${totalSets} 組結束。`;
      $display.className = "time";
    } else if (phase === "paused") {
      $stateChip.textContent = "暫停";
      $badge.textContent = "暫停中";
      $sub.textContent = "按「開始」可續跑。";
      $display.className = "time";
    } else {
      $stateChip.textContent = "待機";
      $badge.textContent = "準備好後按「開始」";
      $sub.textContent = "建議：iPhone 自動鎖定改成「永不」，訓練時不要鎖屏。";
      $display.className = "time";
    }
  }

  function flash(colorClass){
    $flash.className = `flash ${colorClass} on`;
    setTimeout(() => { $flash.className = "flash"; }, 140);
  }

  function ensureAudioUnlocked(){
    if (audioUnlocked) return;
    try{
      audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      // create a silent sound to unlock
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      gain.gain.value = 0.0001;
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.02);
      audioUnlocked = true;
    } catch(e){
      // If audio context fails, we just skip sound gracefully
      audioUnlocked = false;
    }
  }

  function playBeep({freq=880, ms=120} = {}){
    if ($mute.checked) return;
    ensureAudioUnlocked();
    if (!audioUnlocked || !audioCtx) return;

    const vol = Math.max(0, Math.min(1, parseInt($vol.value,10)/100));
    try{
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.value = freq;
      gain.gain.value = 0.08 * vol; // conservative for iPhone speakers
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      setTimeout(() => osc.stop(), ms);
    } catch(e){}
  }

  // iPhone: vibration usually unavailable; kept as best-effort (will no-op on iOS)
  function vibrate(pattern){
    try{
      if ("vibrate" in navigator) navigator.vibrate(pattern);
    } catch(e){}
  }

  function stopTimer(){
    if (timerId) clearInterval(timerId);
    timerId = null;
    setControlsRunning(false);
  }

  function startTimerLoop(){
    setControlsRunning(true);
    timerId = setInterval(tick, 1000);
  }

  // LAST-3 cues: for any active phase (prep/hold/rest)
  function last3Cue(){
    playBeep({freq: 990, ms: 110});
    flash("danger");
    vibrate(60);
  }

  // Phase transition cue
  function transitionCue(kind){
    // kind: "start" | "switch" | "finish"
    if (kind === "start") {
      playBeep({freq: 880, ms: 260});
      flash("warn");
      vibrate([90, 40, 90]);
    } else if (kind === "switch") {
      playBeep({freq: 880, ms: 260});
      flash("accent");
      vibrate([120, 60, 120]);
    } else {
      // finish
      playBeep({freq: 660, ms: 320});
      setTimeout(() => playBeep({freq: 880, ms: 320}), 180);
      flash("accent");
      vibrate([150, 80, 150]);
    }
  }

  function tick(){
    // cue at 3/2/1 before hitting 0
    if (remaining === 3 || remaining === 2 || remaining === 1) {
      last3Cue();
    }

    remaining = Math.max(0, remaining - 1);
    $display.textContent = fmt(remaining);

    if (remaining !== 0) return;

    // reached 0 => transition
    transitionCue("switch");

    if (phase === "prep") {
      currentSet = 1;
      setPhase("hold");
      remaining = holdSec;
      $display.textContent = fmt(remaining);
      return;
    }

    if (phase === "hold") {
      if (currentSet >= totalSets) {
        setPhase("done");
        stopTimer();
        transitionCue("finish");
        return;
      }
      setPhase("rest");
      remaining = restSec;
      $display.textContent = fmt(remaining);
      return;
    }

    if (phase === "rest") {
      currentSet += 1;
      setPhase("hold");
      remaining = holdSec;
      $display.textContent = fmt(remaining);
      return;
    }
  }

  function startOrResume(){
    ensureAudioUnlocked();
    readInputs();

    if (phase === "paused") {
      // resume exactly where you left off
      setPhase(lastActivePhase || "hold");
      startTimerLoop();
      transitionCue("start");
      return;
    }

    // fresh start
    currentSet = 1;
    if (prepSec > 0) {
      setPhase("prep");
      remaining = prepSec;
    } else {
      setPhase("hold");
      remaining = holdSec;
    }
    $display.textContent = fmt(remaining);
    transitionCue("start");
    startTimerLoop();
  }

  let lastActivePhase = "hold";

  function pause(){
    if (!timerId) return;
    clearInterval(timerId);
    timerId = null;
    // remember which phase we paused in
    if (phase === "prep" || phase === "hold" || phase === "rest") {
      lastActivePhase = phase;
    }
    setPhase("paused");
    setControlsRunning(false);
    // keep inputs disabled? better: allow tweaks only after reset; here we allow edits while paused
    // (but it won't affect current run unless user resets)
    [$sets,$hold,$rest,$prep].forEach(el => el.disabled = false);
    $pause.disabled = true;
    $start.disabled = false;
  }

  function reset(){
    stopTimer();
    readInputs();
    setPhase("idle");
    // show preview as HOLD time
    const preview = Math.max(1, parseInt($hold.value || "20", 10));
    remaining = preview;
    $display.textContent = fmt(preview);
  }

  // Events
  $start.addEventListener("click", () => {
    // If currently running, ignore
    if (timerId) return;
    // If done, a new start should restart
    if (phase === "done") reset();
    startOrResume();
  });

  $pause.addEventListener("click", () => pause());
  $reset.addEventListener("click", () => reset());

  // keep display preview updated when idle
  [$hold].forEach(el => el.addEventListener("input", () => {
    if (timerId) return;
    const v = Math.max(1, parseInt($hold.value || "20", 10));
    $display.textContent = fmt(v);
  }));

  // Initial
  setPhase("idle");
  $display.textContent = fmt(parseInt($hold.value || "20", 10));
})();
</script>
</body>
</html>
